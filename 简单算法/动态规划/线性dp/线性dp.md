<h1 style="text-align: center;">线性dp讲义</h1>

### 引入

先来看一道例题：

> [IOI1994] 数字三角形
>
> 给定一个 $r$ 行的数字三角形（$r \leq 1000$)，需要找到一条从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到当前点左下方的点或右下方的点。
>
> ```c++
>         7 
>       3   8 
>     8   1   0 
>   2   7   4   4 
> 4   5   2   6   5 
> ```
>
> 在上面这个例子中，最优路径是 $7 \to 3 \to 8 \to 7 \to 5$。

容易想到可以把所有的情况都列出来，然后找其中的最大值，但是可惜的是，它的路径分支一共有 $2^r$ 条，这样做肯定是会超时的。

观察一下题目中给出的最优路径，往上推一层，如果我们想到达 第 $5$ 行 第 $2$ 列 的这个 $5$ 的话，$7 \to 3 \to 8 \to 7$ 就是最优的路线。

同样的，如果想到达 第 $4$ 行 第 $2$ 列 的 $7$，$7 \to 3 \to 8$ 同样是最优的路线，往上同理。

所以容易发现，对于一条最优路线来说，它的**每一个决策都是对于这条路线来说最优的选择**。

对于上述问题，可以发现，其实对于每一个点，想**到达这个点只能从它的 左上方 或 右上方 到达**。

那么，如果我们能记录下 **到达当前点时的最大和**，就可以从上往下推出所有点的最大和了。

例如：如果记下了 第 $3$ 行 所有点的最大和，那么就可以推出第 $4$ 行的所有点的最大和，比如求 第 $4$ 行第 $2$ 个点的最大和，那么就是 **选 从 第 $3$ 行第 $1$ 个 点 或者 第 $3$ 行第 $2$ 个 点 来到达 第 $4$ 行第 $2$ 个点**，此时肯定是谁更大就选谁，按照这样的策略，就可以推出所有点的最大和。

到这里，其实咱们就进行了一次动态规划算法的基本思路设计，下面让我们更详细的来了解动态规划的思想。

### 原理

**动态规划**（Dynamic programming，简称DP）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

其背后的基本思想非常简单，大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。

使用动态规划来解决问题，这个问题需要满足三个条件：**具备最优子结构**、**无后效性**以及**子问题重叠**。

#### 最优子结构

如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。例如上述题目中，$7 \to 3 \to 8 \to 7 \to 5$ 这条路线中，到达其中任意一个点的路线，都是到这个路线的最优路线。

#### 无后效性

子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。例如上述问题中，在计算第 $3$ 层的最大和时，前面两层所有点的最大和是已经固定不会变的。

#### 子问题重叠

子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。

例如上述问题中，在计算到达当前点的最大和时，需要计算出其 左上方的点 和 右上方的点 的最大和，如果用递归来求解，会重复进行多次计算，而如果记下每个点计算的结果，就可以很快速的知道其最大和。

#### 动态规划基本思路

对于一个能用动态规划解决的问题，一般会采用如下思路来解决：

- 将原问题划分为若干 **阶段**，每个阶段对应若干个子问题，提取这些子问题的特征（称之为 **状态**）；例如数字三角形中，**状态**就是 **到达当前点时的最大和**。
- 寻找每一个状态的可能 **决策**，或者说是各状态间的相互转移方式（用数学的语言描述就是 **状态转移方程**）。例如数字三角形中，要求出当前点的最大和，就是从 左上角的点 和 右上角的点 中选出更大的数字，再加上当前点的数字，就是当前点的最大和。用方程描述就是：**当前点的最大和 = $max($左上角的最大和, 右上角的最大和$)$ + 当前点的数字**。
- 按顺序求解每一个阶段的问题，即循环递推。



### 例题

#### [数字三角形](https://www.luogu.com.cn/problem/P1216)

> [IOI1994] 数字三角形
>
> 给定一个 $r$ 行的数字三角形（$r \leq 1000$)，需要找到一条从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到当前点左下方的点或右下方的点。
>
> ```c++
>         7 
>       3   8 
>     8   1   0 
>   2   7   4   4 
> 4   5   2   6   5 
> ```
>
> 在上面这个例子中，最优路径是 $7 \to 3 \to 8 \to 7 \to 5$。

最优子结构证明：

> 假设到达 $a_n$ 节点的最优路径选择为 $a_1 \to a_2 \to ... \to a_n$，那么这个路线到达 $a_{n-1}$ 一定也是最优的。这个容易利用反证法进行证明，如果到达 $a_{n-1}$ 的路线不是最优的，那么势必有另一个路线的值比这条路线大，就有冲突了。 

假设 $a[i][j]$ 指的是数字三角形中 第 $i$ 行第 $j$ 列 的数字。

**状态**：根据上面的分析可知，我们要记录的就是 **到达当前点的最大和**，所以可以设置 **$dp[i][j]$ 表示 到达 第 $i$ 行 第 $j$ 列的点时的最大和**，这就是状态。

**状态转移方程**：若想到达第 $i$ 行第 $j$ 列的点，可以从 第 $i-1$ 行第 $j-1$ 列 和 第 $i-1$ 行第 $j$ 列 移动过来，如果是从 第 $i-1$ 行第 $j-1$ 列 移动过来，那么总和就是 $dp[i-1][j-1]+a[i][j]$；而如果是从 第 $i-1$ 行第 $j$ 列移动过来，总和就是 $dp[i-1][j]+a[i][j]$，显然我们应该选择两个移动方案中值更大的哪一个。所以状态转移方程就是：$dp[i][j] = max(dp[i-1][j], dp[i-1][j-1])+a[i][j]$ 。

一般来说，编写代码时会设置一个初始状态，方便之后的推导，比如这个题目我们就可以直接设置 $1$ 行 $1$ 列 的状态，即 $dp[1][1] = a[1][1]$ 。

**示例代码：**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1005;
int r;
int a[N][N], dp[N][N]; 
// dp[i][j] 表示到达第i行第j列的最大和是多少 

int main() {
	cin >> r;
	for (int i=1; i<=r; i++) {
		for (int j=1; j<=i; j++) {
			cin >> a[i][j];
		}
	}
	dp[1][1] = a[1][1];  // 设置初始状态 
	for (int i=2; i<=r; i++) {  // 从第二行开始推导 
		for (int j=1; j<=i; j++) {
			// 状态转移方程 
			dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + a[i][j];
		}
	}
	int maxx = 0;
	for (int i=1; i<=r; i++) {
		maxx = max(dp[r][i], maxx);  // 取最后一行的最大值 
	}
	cout << maxx;
	return 0;
}
```

本题也有自底向上的推导顺序，可以尝试自行推导。



#### [最长公共子序列（LCS）](https://oj.noionline.cn/problem/T1265)

> 给定一个字符串 $s$ 和 一个字符串 $t$，输出 $s$ 和 $t$ 的最长公共子序列的长度。
>
> 子序列指：对于一个序列，再不改变元素的相对顺序的情况下删除某些元素（也可以不删除任何元素）后得到的新序列。例如，字符串 "123" 的子序列有："123"、"12"、"13"、"23"、"1"、"2"、"3"

例子：字符串 `abcde` 与字符串 `acde` 的公共子序列有 `a`、`c`、`d`、`e`、`ac`、`ad`、`ae`、`cd`、`ce`、`de`、`ade`、`ace`、`cde`、`acde`，最长公共子序列的长度是 $4$。

最长公共子序列问题具备最优子结构的证明：

> 设 $X=<x_1,x_2,...,x_m>$，$Y=<y_1,y_2,...,y_n>$ 为两个序列，$Z=<z_1,z_2,...,z_k>$ 是 $X$ 和 $Y$ 的任意一个 LCS，则一定有：
>
> - 若 $x_m == y_n$，则一定有 $z_k == x_m == y_n$ 并且 $Z_{k-1}$ 是 $X_{m-1}$ 和 $Y_{n-1}$ 的一个 LCS。
> - 若 $x_m \ne y_n$，存在两种情况：
>   - $z_k \ne x_m$，意味着 $Z$ 是 $X_{m-1}$ 和 $Y$ 的一个 LCS。
>   - $z_k \ne y_n$，意味着 $Z$ 是 $X$ 和 $Y_{n-1}$ 的一个 LCS。
>
> 为了方便理解，此处给出例子：
>
> - 序列 `abcde` 和 `acde`，它们的 LCS 是 `acde`，可以发现最后一个字符一定相等，并且 `acd` 是 `abcd` 和 `acd` 的 LCS。
> - 序列 `abcde` 和 `pacd`，它们的 LCS 是 `acd`，可以发现，`acd` 其实也是 `abcd` 和 `pacd` 的 LCS，反之也一样。

那么可得，如果有两个序列 $X$ 和 $Y$，长度分别为 $n$ 和 $m$，那么：

- 当 $x_n == y_m$ 时，$X$ 和 $Y$ 的 LCS 可以由 $X_{n-1}$ 和 $Y_{m-1}$ 的 LCS 加上 当前的 $x_n$。
- 当 $x_n \ne y_m$ 时，$X$ 和 $Y$ 的 LCS 就是 $X_{n-1}$ 和 $Y$ 的 LCS 与 $X$ 和 $Y_{m-1}$ 的 LCS 中更长的那一个。

以此我们可以来解决此题：

假设序列分别为 $x$ 和 $y$，长度分别为 $n$ 和 $m$。

**状态**：$dp[i][j]$ 表示 序列 $x$ 的前 $i$ 个字符 与 序列 $y$ 的前 $j$ 个字符的 LCS 的长度。

**状态转移方程**：

当 $x_i == y_j$ 时，$dp[i][j] = dp[i-1][j-1]+1$ 。

当 $x_i \ne y_j$ 时，$dp[i][j] = max(dp[i-1][j], dp[i][j-1])$。

**初始状态**：$dp[i][0] = 0,dp[0][j]=0$

**示例代码**：

```c++
#include <bits/stdc++.h>
using namespace std;
string x, y;
int n, m, dp[1005][1005];
// dp[i][j] 表示 x的前i个字符和 y的前j个字符的最长公共子序列的长度 

int main() {
	cin >> x >> y;
	n = x.size(), m = y.size();
	// 初始状态设置，其实可以不用写，因为全局默认是 0 
	for (int i=1; i<=n; i++) dp[i][0] = 0; 
	for (int i=1; i<=m; i++) dp[0][i] = 0; 
    // 推导整个公共子串
	for (int i=1; i<=n; i++) {
		for (int j=1; j<=m; j++) {
			if (x[i-1] == y[j-1]) dp[i][j] = dp[i-1][j-1]+1;
			else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
		}
	}
	cout << dp[n][m];
	return 0;
}
```

时间复杂度为 $O(n \times m)$，本题存在 $O(nlogn)$ 的解法，感兴趣可以先自行了解。



#### [最长上升子序列（LIS）](https://www.luogu.com.cn/problem/B3637)

>给定一个长度为 $n(n \leq 5000)$ 的序列，序列中都是不超过 $10^6$ 的正整数，请求出这个序列的 **最长上升子序列** 的长度。
>
>最长上升子序列指的是：从原序列中按顺序取出一些数字排在一起，这些数字是逐渐增大的。

最优子结构推导：

> 设序列为 $A=<a_1,a_2,...,a_n>$，最长上升子序列为 $B=<b_1,b_2,...,b_m>$。
>
> 我们并不能直接把 LIS 的长度作为规划的目标，例子如下：
>
> 假设有 $a_n == b_m$，那是否有 $<b_1,b_2,...,b_{m-1}>$ 是 $<a_1,a_2,...,b_{m-1}>$ 的 LIS 呢？
>
> 为了方便理解，此处给出例子：
>
> 序列 `1 3 4 2 7 9 6 8` 的 LIS **可以是** `1 3 4 6 8`，长度为 $5$，那么序列 `1 3 4 2 7 9 6` 的 LIS 一定是 `1 3 4 6` 么？明显不是，因为此序列还可以有 LIS 是 `1 3 4 7 9`，所以这样是不存在最优子结构的，因为 **LIS 可能有多个**！
>
> 在此我们引入一个概念，叫 **限界上升子序列**，例如对于元素 $a_i$，**以 $a_i$ 为终点的 上升子序列**，即是 **限界上升子序列**，而其中最长的就是 **最大限界上升子序列** 。
>
> 举个例子，例如序列 `1 3 4 8 2 7` 中，对于元素 `7` 来说，它有如下 **限界上升子序列**：`1 7`、`1 3 7`、`1 4 7`、`1 3 4 7`、`3 7`、`3 4 7`、`4 7`，而其中的 **最大限界上升子序列** 显然是 `1 3 4 7` （可以想一想为什么没有 `1 3 4 8` ）。
>
> 假设序列为 $A=<a_1,a_2,...,a_n>$，最大限界上升子序列为 $B=<b_1,b_2,...,b_m>$。
>
> 那么当 $a_n == b_m$ 是，一定有 $<a_1,a_2,...,b_{m-1}>$ 的最大限界上升子序列为 $<b_1,b_2,...,b_{m-1}>$ 。
>
> 由此可得，最大限界上升子序列是具备最优子结构的。
>
> **而所有最大限界上升子序列中的最大值，就是最长上升子序列。**

以此为基础我们可以解决此题：

假设序列为 $a$，长度为 $n$ 。

**状态**：$dp[i]$ 表示 序列 $a$ 的 中以 $a[i]$ 为终点的 **最大限界上升子序列** 的长度。

**状态转移方程**：$dp[i] = max({dp[j]|j<i,a[j]<a[i]})+1$ 。

**初始状态**：$dp[0] = 0$ 。

最终的结果就是 $max(dp[i]|i<=n)$ 。

**示例代码**：

```c++
#include<bits/stdc++.h>
using namespace std;
int n, a[5005], dp[5005], res;


int main() {
    scanf("%d", &n);
    for (int i=1; i<=n; i++) scanf("%d", &a[i]);
    for (int i=1; i<=n; i++) {
    	dp[i] = 1;  // 默认长度应该是 1
    	for (int j=1; j<i; j++)  // 在前面找所有可能的最大限界上升子序列
    		if (t[j] < t[i]) dp[i] = max(dp[i], dp[j]+1);
    	res = max(res, dp[i]);  // 取最大值
	}
	cout << res;
    return 0;
}
```

可以思考一下如何输出最长上升子序列。

#### [编辑距离（Edit Distance）](https://www.luogu.com.cn/problem/P2758)

> 设 $A$ 和 $B$ 是两个字符串，给定你三种字符操作：
>
> 1. 删除一个字符；
> 2. 插入一个字符；
> 3. 将一个字符改为另一个字符。
>
> 问最少需要操作多少次，可以把 字符串$A$ 转换为 字符串 $B$，字符串 $A,B$ 均只包含小写字母。

最优子结构性质：

> 设 $X=<x_1,x_2,...,x_m>$，$Y=<y_1,y_2,...,y_n>$ 为两个序列，$dp[m][n]$ 表示 把 $X$ 的前 $m$ 个字符 转为 $Y$ 的前 $n$ 个字符的最短编辑距离，那么有如下情况：
>
> - 若 $x_m==y_n$，我们需要编辑的序列就是 $<x1,...,x_{m-1}>$ 和 $<y_1,...,y_{n-1}>$ 那么 $dp[m][n]$ 可以由 $dp[m-1][n-1]$ 得来。
> - 若 $x_m \ne y_n$，我们可以执行如下操作：
>   - 删除 $x_m$，因为 $x_m$ 已经被删除了，那么此时我们要编辑的序列就是 $<x_1,...,x_{m-1}>$ 和 $<y_1,...,y_n>$，也就是说 $dp[m][n]$ 可以由 $dp[m-1][n]$ 得来。
>   - 在 $x_m$ 后面插入一个字符 $y_n$，那么此时我们要编辑的序列就是 $<x_1,...,x_m>$ 和 $<y_1,...,y_{n-1}>$，也就是说 $dp[m][n]$ 可以由 $dp[m][n-1]$ 得来。
>   - 把 $x_m$ 替换为 $y_n$，那么此时我们要编辑的序列就是 $<x_1,...,x_{m-1}>$ 和 $<y_1,...,y_{n-1}>$ ，也就是说 $dp[m][n]$ 可以由 $dp[m-1][n-1]$ 得来。

以此为基础我们可以解决此题：

假设序列分别为 $x,y$，长度为 $m,n$ 。

**状态**：$dp[i][j]$ 表示 把 $x$ 的前 $i$ 个字符 编辑为 $y$ 的前 $j$ 个字符的最短编辑次数。

**状态转移方程**：分为两种情况：

- $x[i]==y[j]$：$dp[i][j] = dp[i-1][j-1]$
- $x[i] \ne y[j]$：$dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])+1$

**初始状态**：$dp[i][0]=i,dp[0][j]=j$ 。

最终的结果就是 $dp[m][n]$ 。

**示例代码**：

```c++
#include <bits/stdc++.h>
using namespace std;
string s1, s2;
int len1, len2;
int dp[2002][2002];  // dp[i][j]表示s1前i个字符转为s2前i个字符 需要的操作数
// dp[i][0] = i;
// dp[0][j] = j;
// dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+1); 

int main(){
	cin >> s1 >> s2;
	len1 = s1.size(), len2 = s2.size();
    // 初始状态
	for (int i=0; i<=len1; i++) dp[i][0] = i;
	for (int j=0; j<=len2; j++) dp[0][j] = j;
    
	for (int i=1; i<=len1; i++) {
		for (int j=1; j<=len2; j++) {
			// 末尾字符相等 这里i-1 j-1是因为下标从0开始。
			if (s1[i-1] == s2[j-1]) dp[i][j] = dp[i-1][j-1];
			else dp[i][j] = min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1])+1;
		}
	}
	cout << dp[len1][len2];
	return 0;
}
```

