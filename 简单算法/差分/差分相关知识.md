<h1 style="text-align: center;">差分讲义</h1>

### 引入

思考如下问题：

> 给定一个长度为 $n$ 的整数序列，接下来进行 $m$ 次操作，每次操作输入三个整数 $l,r,c$，表示将序列中 $[l,r]$ 之间的每个数字加上 $c$，请输出最终的序列。

这个问题很容易想到暴力解，每次都循环遍历 $[l,r]$ 区间，然后依次加 $c$ 即可，核心代码如下：

```c++
int a[100010];
int n, m;
cin >> n >> m;
for (int i = 1; i <= n; i++) cin >> a[i];
while (m--)
{
    int l, r, c;
    cin >> l >> r >> c;
    for (int i = l; i <= r; i++) a[i] += c;
}
for (int i = 1; i <= n; i++) cout << a[i] << " ";
```

容易发现，这个代码的时间复杂度是 $O(m \times n)$ 级别的，如果数据范围较大，代码肯定是超时的。

那么，有没有什么技巧可以 **快速对序列中某一连续区间的值进行修改** 呢？答案就是 —— 差分！

### 一维差分实现

假设原数组为 $a$，差分数组为 $b$，那么 $b[i]$ 表示的是 $a[i]$ 与 $a[i-1]$ 的差，即差分数组的第 $i$ 项等于原数组的第 $i$ 项和第 $i-1$ 项的差，总结：$b[i] = a[i]-a[i-1]$。

容易发现，对差分数组 $b$ 求前缀和即可得出原数组 $a$ ，可以说，差分就是前缀和的逆运算。

![image-20231222151753760](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231222151753760.png)

可以尝试一下，如果 差分数组 $b$ 中的某一项的值发生了改变，那么通过前缀和求出来的原数组 $a$ 会发生什么呢？例如上面的 $b[4]$ 如果从 $-2$ 变成了 $0$，即增加了 $2$

那么还原出来的 $a$ 序列就会变成 $[0,5,12,18,18,26,29,31,26,27]$，后面的所有元素都增加了 $2$ ！

那如果此时再让 $b[7]$ 减少 $2$ 呢？即 $b[7]$ 从 $2$ 变成了 $0$，那么再求 $a$ 序列，会得到：

$[0, 5, 12, 18, 18, 26, 29, 29, 24, 25]$，发现了么，现在变成了 区间 $[4, 6]$ 之间增加了 $2$，其他的元素保持不变！那么再往下推导，如果想要 原序列中区间 $[l, r]$ 中的元素都增加 $c$，就把 差分数组中的 $b[l]+c$，$b[r+1]-c$ 即可。

这样每次只需要改变两个元素的值，所以就达到了 **快速对序列中某一连续区间的值进行修改** 的目的。

总结，利用差分数组来改变原数组中的区间值，操作步骤如下：

- 根据原数组求出差分数组 $b$。
- 要使 $[l, r]$ 区间的值 增加 $c$，就让 $b[l]+c,b[r+1]-c$。
- 求出差分数组 $b$ 的前缀和，即可得到修改后的原数组。

下面来看看如何解决上面的问题，核心代码如下：

```c++
int n, q, a[100010], b[100010];
int main() 
{
    cin >> n >> q;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) {
        b[i] = a[i] - a[i - 1]; // 构造a的差分数组b
    }
    while (q--)
    {
        int l, r, c;
        cin >> l >> r >> c;
        b[l] += c;   // 操作差分数组b
        b[r+1] -= c;
    }
    for (int i = 1; i <= n; i++) {
        b[i] += b[i-1];
        cout << b[i] << " "; // 对b求前缀和得到修改后的a
    }
    return 0;
}
```

### 二维差分实现

一维差分可以在一个序列中快速修改某个连续区间的值，那二维差分就可以在一个矩阵中 **快速修改某一子矩阵的值** 。

根据一维差分的定义，我们已经得知，差分就是前缀和的逆运算，二维也是相同的概念，如果对于**一个 矩阵 $s$，是 矩阵 $a$ 的前缀和矩阵，那么 矩阵 $a$ 是矩阵 $s$ 的差分矩阵**。

根据二维前缀和的递推公式：$s[i][j] = s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]$ 

可得，二维差分的递推公式：$a[i][j] = s[i][j]+s[i-1][j-1]-s[i-1][j]-s[i][j-1]$

那么，应该如何对差分矩阵 $a$ 进行操作，使得矩阵 $s$ 中   左上角坐标为 $(x1, y1)$，右下角的坐标为 $(x2, y2)$ 的矩阵元素都增加 $c$ 呢？请看下面的图示：

![4c3fd016f43e4aabad43b43f70d807e2.png](https://img-blog.csdnimg.cn/4c3fd016f43e4aabad43b43f70d807e2.png)

可以发现，如果要将 左上角坐标为 $(x1, y1)$，右下角的坐标为 $(x2, y2)$ 的矩阵元素都增加 $c$ ，就对差分矩阵 $a$ 进行如下操作：

- $a[x1][y1]+c$
- $a[x2+1][y1]-c$
- $a[x1][y2+1]-c$
- $a[x2+1][y2+1]+c$

语句较多，建议定义成函数来完成这个操作。示例：

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1010;
int a[N][N], b[N][N];

void insert(int x1, int y1, int x2, int y2, int c) {
    // 使得差分矩阵的指定区域增加 c
    b[x1][y1] += c;
    b[x2+1][y1] -= c;
    b[x1][y2+1] -= c;
    b[x2+1][y2+1] += c;
}

int main() {
    int n, m, q;
    cin >> n >> m >> q;
    // 数据读入a
    for (int i=1; i<=n; i++)
        for (int j=1; j<=m; j++)
            cin >> a[i][j];
    
    // 构造a的差分数组b
    for (int i=1; i<=n; i++)
        for (int j=1; j<=m; j++)
            b[i][j] = a[i][j] + a[i-1][j-1] - a[i-1][j] - a[i][j-1];
    // q次操作
    while (q--) {
        int x1, y1, x2, y2, c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        insert(x1, y1, x2, y2, c);
    }
    // 对b求一次前缀和，得到修改后的a
    for (int i=1; i<=n; i++)
        for (int j=1; j<=m; j++)
            b[i][j] = b[i-1][j] + b[i][j-1] - b[i-1][j-1] + b[i][j];
    // 输出
    for (int i=1; i<=n; i++) {
        for (int j=1; j<=m; j++) {
            cout << b[i][j] << " ";
        }
        cout << endl;
    }
        
    return 0;
}
```

